package types

// Code generated by github.com/CovenantSQL/HashStablePack DO NOT EDIT.

import (
	"github.com/CovenantSQL/HashStablePack/msgp"
)

// MarshalHash marshals for hash
func (z *Ack) MarshalHash() (o []byte, err error) {
	var b []byte
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	o = append(o, 0x82, 0x82)
	if oTemp, err := z.Envelope.MarshalHash(); err != nil {
		return nil, err
	} else {
		o = msgp.AppendBytes(o, oTemp)
	}
	o = append(o, 0x82)
	if oTemp, err := z.Header.MarshalHash(); err != nil {
		return nil, err
	} else {
		o = msgp.AppendBytes(o, oTemp)
	}
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Ack) Msgsize() (s int) {
	s = 1 + 9 + z.Envelope.Msgsize() + 7 + z.Header.Msgsize()
	return
}

// MarshalHash marshals for hash
func (z *AckHeader) MarshalHash() (o []byte, err error) {
	var b []byte
	o = msgp.Require(b, z.Msgsize())
	// map header, size 3
	o = append(o, 0x83, 0x83)
	if oTemp, err := z.Response.MarshalHash(); err != nil {
		return nil, err
	} else {
		o = msgp.AppendBytes(o, oTemp)
	}
	o = append(o, 0x83)
	if oTemp, err := z.NodeID.MarshalHash(); err != nil {
		return nil, err
	} else {
		o = msgp.AppendBytes(o, oTemp)
	}
	o = append(o, 0x83)
	o = msgp.AppendTime(o, z.Timestamp)
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *AckHeader) Msgsize() (s int) {
	s = 1 + 9 + z.Response.Msgsize() + 7 + z.NodeID.Msgsize() + 10 + msgp.TimeSize
	return
}

// MarshalHash marshals for hash
func (z AckResponse) MarshalHash() (o []byte, err error) {
	var b []byte
	o = msgp.Require(b, z.Msgsize())
	// map header, size 0
	o = append(o, 0x80)
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z AckResponse) Msgsize() (s int) {
	s = 1
	return
}

// MarshalHash marshals for hash
func (z *AggrNoAckReport) MarshalHash() (o []byte, err error) {
	var b []byte
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	o = append(o, 0x82, 0x82)
	if oTemp, err := z.Envelope.MarshalHash(); err != nil {
		return nil, err
	} else {
		o = msgp.AppendBytes(o, oTemp)
	}
	o = append(o, 0x82)
	if oTemp, err := z.Header.MarshalHash(); err != nil {
		return nil, err
	} else {
		o = msgp.AppendBytes(o, oTemp)
	}
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *AggrNoAckReport) Msgsize() (s int) {
	s = 1 + 9 + z.Envelope.Msgsize() + 7 + z.Header.Msgsize()
	return
}

// MarshalHash marshals for hash
func (z *AggrNoAckReportHeader) MarshalHash() (o []byte, err error) {
	var b []byte
	o = msgp.Require(b, z.Msgsize())
	// map header, size 4
	o = append(o, 0x84, 0x84)
	if oTemp, err := z.NodeID.MarshalHash(); err != nil {
		return nil, err
	} else {
		o = msgp.AppendBytes(o, oTemp)
	}
	o = append(o, 0x84)
	o = msgp.AppendTime(o, z.Timestamp)
	o = append(o, 0x84)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Reports)))
	for za0001 := range z.Reports {
		if oTemp, err := z.Reports[za0001].MarshalHash(); err != nil {
			return nil, err
		} else {
			o = msgp.AppendBytes(o, oTemp)
		}
	}
	o = append(o, 0x84)
	if z.Peers == nil {
		o = msgp.AppendNil(o)
	} else {
		if oTemp, err := z.Peers.MarshalHash(); err != nil {
			return nil, err
		} else {
			o = msgp.AppendBytes(o, oTemp)
		}
	}
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *AggrNoAckReportHeader) Msgsize() (s int) {
	s = 1 + 7 + z.NodeID.Msgsize() + 10 + msgp.TimeSize + 8 + msgp.ArrayHeaderSize
	for za0001 := range z.Reports {
		s += z.Reports[za0001].Msgsize()
	}
	s += 6
	if z.Peers == nil {
		s += msgp.NilSize
	} else {
		s += z.Peers.Msgsize()
	}
	return
}

// MarshalHash marshals for hash
func (z *InitService) MarshalHash() (o []byte, err error) {
	var b []byte
	o = msgp.Require(b, z.Msgsize())
	// map header, size 1
	o = append(o, 0x81, 0x81)
	if oTemp, err := z.Envelope.MarshalHash(); err != nil {
		return nil, err
	} else {
		o = msgp.AppendBytes(o, oTemp)
	}
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *InitService) Msgsize() (s int) {
	s = 1 + 9 + z.Envelope.Msgsize()
	return
}

// MarshalHash marshals for hash
func (z *InitServiceResponse) MarshalHash() (o []byte, err error) {
	var b []byte
	o = msgp.Require(b, z.Msgsize())
	// map header, size 1
	o = append(o, 0x81, 0x81)
	if oTemp, err := z.Header.MarshalHash(); err != nil {
		return nil, err
	} else {
		o = msgp.AppendBytes(o, oTemp)
	}
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *InitServiceResponse) Msgsize() (s int) {
	s = 1 + 7 + z.Header.Msgsize()
	return
}

// MarshalHash marshals for hash
func (z *InitServiceResponseHeader) MarshalHash() (o []byte, err error) {
	var b []byte
	o = msgp.Require(b, z.Msgsize())
	// map header, size 1
	o = append(o, 0x81, 0x81)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Instances)))
	for za0001 := range z.Instances {
		if oTemp, err := z.Instances[za0001].MarshalHash(); err != nil {
			return nil, err
		} else {
			o = msgp.AppendBytes(o, oTemp)
		}
	}
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *InitServiceResponseHeader) Msgsize() (s int) {
	s = 1 + 10 + msgp.ArrayHeaderSize
	for za0001 := range z.Instances {
		s += z.Instances[za0001].Msgsize()
	}
	return
}

// MarshalHash marshals for hash
func (z *NoAckReport) MarshalHash() (o []byte, err error) {
	var b []byte
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	o = append(o, 0x82, 0x82)
	if oTemp, err := z.Envelope.MarshalHash(); err != nil {
		return nil, err
	} else {
		o = msgp.AppendBytes(o, oTemp)
	}
	o = append(o, 0x82)
	if oTemp, err := z.Header.MarshalHash(); err != nil {
		return nil, err
	} else {
		o = msgp.AppendBytes(o, oTemp)
	}
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *NoAckReport) Msgsize() (s int) {
	s = 1 + 9 + z.Envelope.Msgsize() + 7 + z.Header.Msgsize()
	return
}

// MarshalHash marshals for hash
func (z *NoAckReportHeader) MarshalHash() (o []byte, err error) {
	var b []byte
	o = msgp.Require(b, z.Msgsize())
	// map header, size 3
	o = append(o, 0x83, 0x83)
	if oTemp, err := z.NodeID.MarshalHash(); err != nil {
		return nil, err
	} else {
		o = msgp.AppendBytes(o, oTemp)
	}
	o = append(o, 0x83)
	o = msgp.AppendTime(o, z.Timestamp)
	o = append(o, 0x83)
	if oTemp, err := z.Response.MarshalHash(); err != nil {
		return nil, err
	} else {
		o = msgp.AppendBytes(o, oTemp)
	}
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *NoAckReportHeader) Msgsize() (s int) {
	s = 1 + 7 + z.NodeID.Msgsize() + 10 + msgp.TimeSize + 9 + z.Response.Msgsize()
	return
}

// MarshalHash marshals for hash
func (z *QueryKey) MarshalHash() (o []byte, err error) {
	var b []byte
	o = msgp.Require(b, z.Msgsize())
	// map header, size 3
	o = append(o, 0x83, 0x83)
	if oTemp, err := z.NodeID.MarshalHash(); err != nil {
		return nil, err
	} else {
		o = msgp.AppendBytes(o, oTemp)
	}
	o = append(o, 0x83)
	o = msgp.AppendUint64(o, z.ConnectionID)
	o = append(o, 0x83)
	o = msgp.AppendUint64(o, z.SeqNo)
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *QueryKey) Msgsize() (s int) {
	s = 1 + 7 + z.NodeID.Msgsize() + 13 + msgp.Uint64Size + 6 + msgp.Uint64Size
	return
}

// MarshalHash marshals for hash
func (z QueryType) MarshalHash() (o []byte, err error) {
	var b []byte
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendInt32(o, int32(z))
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z QueryType) Msgsize() (s int) {
	s = msgp.Int32Size
	return
}

// MarshalHash marshals for hash
func (z *RequestHeader) MarshalHash() (o []byte, err error) {
	var b []byte
	o = msgp.Require(b, z.Msgsize())
	// map header, size 8
	o = append(o, 0x88, 0x88)
	o = msgp.AppendInt32(o, int32(z.QueryType))
	o = append(o, 0x88)
	if oTemp, err := z.NodeID.MarshalHash(); err != nil {
		return nil, err
	} else {
		o = msgp.AppendBytes(o, oTemp)
	}
	o = append(o, 0x88)
	if oTemp, err := z.DatabaseID.MarshalHash(); err != nil {
		return nil, err
	} else {
		o = msgp.AppendBytes(o, oTemp)
	}
	o = append(o, 0x88)
	o = msgp.AppendUint64(o, z.ConnectionID)
	o = append(o, 0x88)
	o = msgp.AppendUint64(o, z.SeqNo)
	o = append(o, 0x88)
	o = msgp.AppendTime(o, z.Timestamp)
	o = append(o, 0x88)
	o = msgp.AppendUint64(o, z.BatchCount)
	o = append(o, 0x88)
	if oTemp, err := z.QueriesHash.MarshalHash(); err != nil {
		return nil, err
	} else {
		o = msgp.AppendBytes(o, oTemp)
	}
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *RequestHeader) Msgsize() (s int) {
	s = 1 + 10 + msgp.Int32Size + 7 + z.NodeID.Msgsize() + 11 + z.DatabaseID.Msgsize() + 13 + msgp.Uint64Size + 6 + msgp.Uint64Size + 10 + msgp.TimeSize + 11 + msgp.Uint64Size + 12 + z.QueriesHash.Msgsize()
	return
}

// MarshalHash marshals for hash
func (z *ResourceMeta) MarshalHash() (o []byte, err error) {
	var b []byte
	o = msgp.Require(b, z.Msgsize())
	// map header, size 4
	o = append(o, 0x84, 0x84)
	o = msgp.AppendUint16(o, z.Node)
	o = append(o, 0x84)
	o = msgp.AppendUint64(o, z.Space)
	o = append(o, 0x84)
	o = msgp.AppendUint64(o, z.Memory)
	o = append(o, 0x84)
	o = msgp.AppendUint64(o, z.LoadAvgPerCPU)
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *ResourceMeta) Msgsize() (s int) {
	s = 1 + 5 + msgp.Uint16Size + 6 + msgp.Uint64Size + 7 + msgp.Uint64Size + 14 + msgp.Uint64Size
	return
}

// MarshalHash marshals for hash
func (z *Response) MarshalHash() (o []byte, err error) {
	var b []byte
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	o = append(o, 0x82, 0x82)
	if oTemp, err := z.Header.MarshalHash(); err != nil {
		return nil, err
	} else {
		o = msgp.AppendBytes(o, oTemp)
	}
	o = append(o, 0x82)
	if oTemp, err := z.Payload.MarshalHash(); err != nil {
		return nil, err
	} else {
		o = msgp.AppendBytes(o, oTemp)
	}
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Response) Msgsize() (s int) {
	s = 1 + 7 + z.Header.Msgsize() + 8 + z.Payload.Msgsize()
	return
}

// MarshalHash marshals for hash
func (z *ResponseHeader) MarshalHash() (o []byte, err error) {
	var b []byte
	o = msgp.Require(b, z.Msgsize())
	// map header, size 5
	o = append(o, 0x85, 0x85)
	if oTemp, err := z.Request.MarshalHash(); err != nil {
		return nil, err
	} else {
		o = msgp.AppendBytes(o, oTemp)
	}
	o = append(o, 0x85)
	if oTemp, err := z.NodeID.MarshalHash(); err != nil {
		return nil, err
	} else {
		o = msgp.AppendBytes(o, oTemp)
	}
	o = append(o, 0x85)
	o = msgp.AppendTime(o, z.Timestamp)
	o = append(o, 0x85)
	o = msgp.AppendUint64(o, z.RowCount)
	o = append(o, 0x85)
	if oTemp, err := z.DataHash.MarshalHash(); err != nil {
		return nil, err
	} else {
		o = msgp.AppendBytes(o, oTemp)
	}
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *ResponseHeader) Msgsize() (s int) {
	s = 1 + 8 + z.Request.Msgsize() + 7 + z.NodeID.Msgsize() + 10 + msgp.TimeSize + 9 + msgp.Uint64Size + 9 + z.DataHash.Msgsize()
	return
}

// MarshalHash marshals for hash
func (z *ResponsePayload) MarshalHash() (o []byte, err error) {
	var b []byte
	o = msgp.Require(b, z.Msgsize())
	// map header, size 3
	o = append(o, 0x83, 0x83)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Columns)))
	for za0001 := range z.Columns {
		o = msgp.AppendString(o, z.Columns[za0001])
	}
	o = append(o, 0x83)
	o = msgp.AppendArrayHeader(o, uint32(len(z.DeclTypes)))
	for za0002 := range z.DeclTypes {
		o = msgp.AppendString(o, z.DeclTypes[za0002])
	}
	o = append(o, 0x83)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Rows)))
	for za0003 := range z.Rows {
		// map header, size 1
		o = append(o, 0x81, 0x81)
		o = msgp.AppendArrayHeader(o, uint32(len(z.Rows[za0003].Values)))
		for za0004 := range z.Rows[za0003].Values {
			o, err = msgp.AppendIntf(o, z.Rows[za0003].Values[za0004])
			if err != nil {
				return
			}
		}
	}
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *ResponsePayload) Msgsize() (s int) {
	s = 1 + 8 + msgp.ArrayHeaderSize
	for za0001 := range z.Columns {
		s += msgp.StringPrefixSize + len(z.Columns[za0001])
	}
	s += 10 + msgp.ArrayHeaderSize
	for za0002 := range z.DeclTypes {
		s += msgp.StringPrefixSize + len(z.DeclTypes[za0002])
	}
	s += 5 + msgp.ArrayHeaderSize
	for za0003 := range z.Rows {
		s += 1 + 7 + msgp.ArrayHeaderSize
		for za0004 := range z.Rows[za0003].Values {
			s += msgp.GuessSize(z.Rows[za0003].Values[za0004])
		}
	}
	return
}

// MarshalHash marshals for hash
func (z *ResponseRow) MarshalHash() (o []byte, err error) {
	var b []byte
	o = msgp.Require(b, z.Msgsize())
	// map header, size 1
	o = append(o, 0x81, 0x81)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Values)))
	for za0001 := range z.Values {
		o, err = msgp.AppendIntf(o, z.Values[za0001])
		if err != nil {
			return
		}
	}
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *ResponseRow) Msgsize() (s int) {
	s = 1 + 7 + msgp.ArrayHeaderSize
	for za0001 := range z.Values {
		s += msgp.GuessSize(z.Values[za0001])
	}
	return
}

// MarshalHash marshals for hash
func (z *ServiceInstance) MarshalHash() (o []byte, err error) {
	var b []byte
	o = msgp.Require(b, z.Msgsize())
	// map header, size 4
	o = append(o, 0x84, 0x84)
	if oTemp, err := z.DatabaseID.MarshalHash(); err != nil {
		return nil, err
	} else {
		o = msgp.AppendBytes(o, oTemp)
	}
	o = append(o, 0x84)
	if z.Peers == nil {
		o = msgp.AppendNil(o)
	} else {
		if oTemp, err := z.Peers.MarshalHash(); err != nil {
			return nil, err
		} else {
			o = msgp.AppendBytes(o, oTemp)
		}
	}
	o = append(o, 0x84)
	if oTemp, err := z.ResourceMeta.MarshalHash(); err != nil {
		return nil, err
	} else {
		o = msgp.AppendBytes(o, oTemp)
	}
	o = append(o, 0x84)
	if z.GenesisBlock == nil {
		o = msgp.AppendNil(o)
	} else {
		if oTemp, err := z.GenesisBlock.MarshalHash(); err != nil {
			return nil, err
		} else {
			o = msgp.AppendBytes(o, oTemp)
		}
	}
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *ServiceInstance) Msgsize() (s int) {
	s = 1 + 11 + z.DatabaseID.Msgsize() + 6
	if z.Peers == nil {
		s += msgp.NilSize
	} else {
		s += z.Peers.Msgsize()
	}
	s += 13 + z.ResourceMeta.Msgsize() + 13
	if z.GenesisBlock == nil {
		s += msgp.NilSize
	} else {
		s += z.GenesisBlock.Msgsize()
	}
	return
}

// MarshalHash marshals for hash
func (z *SignedAckHeader) MarshalHash() (o []byte, err error) {
	var b []byte
	o = msgp.Require(b, z.Msgsize())
	// map header, size 4
	// map header, size 3
	o = append(o, 0x84, 0x84, 0x83, 0x83)
	if oTemp, err := z.AckHeader.Response.MarshalHash(); err != nil {
		return nil, err
	} else {
		o = msgp.AppendBytes(o, oTemp)
	}
	o = append(o, 0x83)
	if oTemp, err := z.AckHeader.NodeID.MarshalHash(); err != nil {
		return nil, err
	} else {
		o = msgp.AppendBytes(o, oTemp)
	}
	o = append(o, 0x83)
	o = msgp.AppendTime(o, z.AckHeader.Timestamp)
	o = append(o, 0x84)
	if oTemp, err := z.HeaderHash.MarshalHash(); err != nil {
		return nil, err
	} else {
		o = msgp.AppendBytes(o, oTemp)
	}
	o = append(o, 0x84)
	if z.Signee == nil {
		o = msgp.AppendNil(o)
	} else {
		if oTemp, err := z.Signee.MarshalHash(); err != nil {
			return nil, err
		} else {
			o = msgp.AppendBytes(o, oTemp)
		}
	}
	o = append(o, 0x84)
	if z.Signature == nil {
		o = msgp.AppendNil(o)
	} else {
		if oTemp, err := z.Signature.MarshalHash(); err != nil {
			return nil, err
		} else {
			o = msgp.AppendBytes(o, oTemp)
		}
	}
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *SignedAckHeader) Msgsize() (s int) {
	s = 1 + 10 + 1 + 9 + z.AckHeader.Response.Msgsize() + 7 + z.AckHeader.NodeID.Msgsize() + 10 + msgp.TimeSize + 11 + z.HeaderHash.Msgsize() + 7
	if z.Signee == nil {
		s += msgp.NilSize
	} else {
		s += z.Signee.Msgsize()
	}
	s += 10
	if z.Signature == nil {
		s += msgp.NilSize
	} else {
		s += z.Signature.Msgsize()
	}
	return
}

// MarshalHash marshals for hash
func (z *SignedAggrNoAckReportHeader) MarshalHash() (o []byte, err error) {
	var b []byte
	o = msgp.Require(b, z.Msgsize())
	// map header, size 4
	o = append(o, 0x84, 0x84)
	if oTemp, err := z.AggrNoAckReportHeader.MarshalHash(); err != nil {
		return nil, err
	} else {
		o = msgp.AppendBytes(o, oTemp)
	}
	o = append(o, 0x84)
	if oTemp, err := z.HeaderHash.MarshalHash(); err != nil {
		return nil, err
	} else {
		o = msgp.AppendBytes(o, oTemp)
	}
	o = append(o, 0x84)
	if z.Signee == nil {
		o = msgp.AppendNil(o)
	} else {
		if oTemp, err := z.Signee.MarshalHash(); err != nil {
			return nil, err
		} else {
			o = msgp.AppendBytes(o, oTemp)
		}
	}
	o = append(o, 0x84)
	if z.Signature == nil {
		o = msgp.AppendNil(o)
	} else {
		if oTemp, err := z.Signature.MarshalHash(); err != nil {
			return nil, err
		} else {
			o = msgp.AppendBytes(o, oTemp)
		}
	}
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *SignedAggrNoAckReportHeader) Msgsize() (s int) {
	s = 1 + 22 + z.AggrNoAckReportHeader.Msgsize() + 11 + z.HeaderHash.Msgsize() + 7
	if z.Signee == nil {
		s += msgp.NilSize
	} else {
		s += z.Signee.Msgsize()
	}
	s += 10
	if z.Signature == nil {
		s += msgp.NilSize
	} else {
		s += z.Signature.Msgsize()
	}
	return
}

// MarshalHash marshals for hash
func (z *SignedInitServiceResponseHeader) MarshalHash() (o []byte, err error) {
	var b []byte
	o = msgp.Require(b, z.Msgsize())
	// map header, size 4
	// map header, size 1
	o = append(o, 0x84, 0x84, 0x81, 0x81)
	o = msgp.AppendArrayHeader(o, uint32(len(z.InitServiceResponseHeader.Instances)))
	for za0001 := range z.InitServiceResponseHeader.Instances {
		if oTemp, err := z.InitServiceResponseHeader.Instances[za0001].MarshalHash(); err != nil {
			return nil, err
		} else {
			o = msgp.AppendBytes(o, oTemp)
		}
	}
	o = append(o, 0x84)
	if oTemp, err := z.HeaderHash.MarshalHash(); err != nil {
		return nil, err
	} else {
		o = msgp.AppendBytes(o, oTemp)
	}
	o = append(o, 0x84)
	if z.Signee == nil {
		o = msgp.AppendNil(o)
	} else {
		if oTemp, err := z.Signee.MarshalHash(); err != nil {
			return nil, err
		} else {
			o = msgp.AppendBytes(o, oTemp)
		}
	}
	o = append(o, 0x84)
	if z.Signature == nil {
		o = msgp.AppendNil(o)
	} else {
		if oTemp, err := z.Signature.MarshalHash(); err != nil {
			return nil, err
		} else {
			o = msgp.AppendBytes(o, oTemp)
		}
	}
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *SignedInitServiceResponseHeader) Msgsize() (s int) {
	s = 1 + 26 + 1 + 10 + msgp.ArrayHeaderSize
	for za0001 := range z.InitServiceResponseHeader.Instances {
		s += z.InitServiceResponseHeader.Instances[za0001].Msgsize()
	}
	s += 11 + z.HeaderHash.Msgsize() + 7
	if z.Signee == nil {
		s += msgp.NilSize
	} else {
		s += z.Signee.Msgsize()
	}
	s += 10
	if z.Signature == nil {
		s += msgp.NilSize
	} else {
		s += z.Signature.Msgsize()
	}
	return
}

// MarshalHash marshals for hash
func (z *SignedNoAckReportHeader) MarshalHash() (o []byte, err error) {
	var b []byte
	o = msgp.Require(b, z.Msgsize())
	// map header, size 4
	// map header, size 3
	o = append(o, 0x84, 0x84, 0x83, 0x83)
	if oTemp, err := z.NoAckReportHeader.NodeID.MarshalHash(); err != nil {
		return nil, err
	} else {
		o = msgp.AppendBytes(o, oTemp)
	}
	o = append(o, 0x83)
	o = msgp.AppendTime(o, z.NoAckReportHeader.Timestamp)
	o = append(o, 0x83)
	if oTemp, err := z.NoAckReportHeader.Response.MarshalHash(); err != nil {
		return nil, err
	} else {
		o = msgp.AppendBytes(o, oTemp)
	}
	o = append(o, 0x84)
	if oTemp, err := z.HeaderHash.MarshalHash(); err != nil {
		return nil, err
	} else {
		o = msgp.AppendBytes(o, oTemp)
	}
	o = append(o, 0x84)
	if z.Signee == nil {
		o = msgp.AppendNil(o)
	} else {
		if oTemp, err := z.Signee.MarshalHash(); err != nil {
			return nil, err
		} else {
			o = msgp.AppendBytes(o, oTemp)
		}
	}
	o = append(o, 0x84)
	if z.Signature == nil {
		o = msgp.AppendNil(o)
	} else {
		if oTemp, err := z.Signature.MarshalHash(); err != nil {
			return nil, err
		} else {
			o = msgp.AppendBytes(o, oTemp)
		}
	}
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *SignedNoAckReportHeader) Msgsize() (s int) {
	s = 1 + 18 + 1 + 7 + z.NoAckReportHeader.NodeID.Msgsize() + 10 + msgp.TimeSize + 9 + z.NoAckReportHeader.Response.Msgsize() + 11 + z.HeaderHash.Msgsize() + 7
	if z.Signee == nil {
		s += msgp.NilSize
	} else {
		s += z.Signee.Msgsize()
	}
	s += 10
	if z.Signature == nil {
		s += msgp.NilSize
	} else {
		s += z.Signature.Msgsize()
	}
	return
}

// MarshalHash marshals for hash
func (z *SignedRequestHeader) MarshalHash() (o []byte, err error) {
	var b []byte
	o = msgp.Require(b, z.Msgsize())
	// map header, size 4
	o = append(o, 0x84, 0x84)
	if oTemp, err := z.RequestHeader.MarshalHash(); err != nil {
		return nil, err
	} else {
		o = msgp.AppendBytes(o, oTemp)
	}
	o = append(o, 0x84)
	if oTemp, err := z.HeaderHash.MarshalHash(); err != nil {
		return nil, err
	} else {
		o = msgp.AppendBytes(o, oTemp)
	}
	o = append(o, 0x84)
	if z.Signee == nil {
		o = msgp.AppendNil(o)
	} else {
		if oTemp, err := z.Signee.MarshalHash(); err != nil {
			return nil, err
		} else {
			o = msgp.AppendBytes(o, oTemp)
		}
	}
	o = append(o, 0x84)
	if z.Signature == nil {
		o = msgp.AppendNil(o)
	} else {
		if oTemp, err := z.Signature.MarshalHash(); err != nil {
			return nil, err
		} else {
			o = msgp.AppendBytes(o, oTemp)
		}
	}
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *SignedRequestHeader) Msgsize() (s int) {
	s = 1 + 14 + z.RequestHeader.Msgsize() + 11 + z.HeaderHash.Msgsize() + 7
	if z.Signee == nil {
		s += msgp.NilSize
	} else {
		s += z.Signee.Msgsize()
	}
	s += 10
	if z.Signature == nil {
		s += msgp.NilSize
	} else {
		s += z.Signature.Msgsize()
	}
	return
}

// MarshalHash marshals for hash
func (z *SignedResponseHeader) MarshalHash() (o []byte, err error) {
	var b []byte
	o = msgp.Require(b, z.Msgsize())
	// map header, size 4
	o = append(o, 0x84, 0x84)
	if oTemp, err := z.ResponseHeader.MarshalHash(); err != nil {
		return nil, err
	} else {
		o = msgp.AppendBytes(o, oTemp)
	}
	o = append(o, 0x84)
	if oTemp, err := z.HeaderHash.MarshalHash(); err != nil {
		return nil, err
	} else {
		o = msgp.AppendBytes(o, oTemp)
	}
	o = append(o, 0x84)
	if z.Signee == nil {
		o = msgp.AppendNil(o)
	} else {
		if oTemp, err := z.Signee.MarshalHash(); err != nil {
			return nil, err
		} else {
			o = msgp.AppendBytes(o, oTemp)
		}
	}
	o = append(o, 0x84)
	if z.Signature == nil {
		o = msgp.AppendNil(o)
	} else {
		if oTemp, err := z.Signature.MarshalHash(); err != nil {
			return nil, err
		} else {
			o = msgp.AppendBytes(o, oTemp)
		}
	}
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *SignedResponseHeader) Msgsize() (s int) {
	s = 1 + 15 + z.ResponseHeader.Msgsize() + 11 + z.HeaderHash.Msgsize() + 7
	if z.Signee == nil {
		s += msgp.NilSize
	} else {
		s += z.Signee.Msgsize()
	}
	s += 10
	if z.Signature == nil {
		s += msgp.NilSize
	} else {
		s += z.Signature.Msgsize()
	}
	return
}

// MarshalHash marshals for hash
func (z *SignedUpdateServiceHeader) MarshalHash() (o []byte, err error) {
	var b []byte
	o = msgp.Require(b, z.Msgsize())
	// map header, size 4
	// map header, size 2
	o = append(o, 0x84, 0x84, 0x82, 0x82)
	o = msgp.AppendInt32(o, int32(z.UpdateServiceHeader.Op))
	o = append(o, 0x82)
	if oTemp, err := z.UpdateServiceHeader.Instance.MarshalHash(); err != nil {
		return nil, err
	} else {
		o = msgp.AppendBytes(o, oTemp)
	}
	o = append(o, 0x84)
	if oTemp, err := z.HeaderHash.MarshalHash(); err != nil {
		return nil, err
	} else {
		o = msgp.AppendBytes(o, oTemp)
	}
	o = append(o, 0x84)
	if z.Signee == nil {
		o = msgp.AppendNil(o)
	} else {
		if oTemp, err := z.Signee.MarshalHash(); err != nil {
			return nil, err
		} else {
			o = msgp.AppendBytes(o, oTemp)
		}
	}
	o = append(o, 0x84)
	if z.Signature == nil {
		o = msgp.AppendNil(o)
	} else {
		if oTemp, err := z.Signature.MarshalHash(); err != nil {
			return nil, err
		} else {
			o = msgp.AppendBytes(o, oTemp)
		}
	}
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *SignedUpdateServiceHeader) Msgsize() (s int) {
	s = 1 + 20 + 1 + 3 + msgp.Int32Size + 9 + z.UpdateServiceHeader.Instance.Msgsize() + 11 + z.HeaderHash.Msgsize() + 7
	if z.Signee == nil {
		s += msgp.NilSize
	} else {
		s += z.Signee.Msgsize()
	}
	s += 10
	if z.Signature == nil {
		s += msgp.NilSize
	} else {
		s += z.Signature.Msgsize()
	}
	return
}

// MarshalHash marshals for hash
func (z *UpdateService) MarshalHash() (o []byte, err error) {
	var b []byte
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	o = append(o, 0x82, 0x82)
	if oTemp, err := z.Envelope.MarshalHash(); err != nil {
		return nil, err
	} else {
		o = msgp.AppendBytes(o, oTemp)
	}
	o = append(o, 0x82)
	if oTemp, err := z.Header.MarshalHash(); err != nil {
		return nil, err
	} else {
		o = msgp.AppendBytes(o, oTemp)
	}
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *UpdateService) Msgsize() (s int) {
	s = 1 + 9 + z.Envelope.Msgsize() + 7 + z.Header.Msgsize()
	return
}

// MarshalHash marshals for hash
func (z *UpdateServiceHeader) MarshalHash() (o []byte, err error) {
	var b []byte
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	o = append(o, 0x82, 0x82)
	o = msgp.AppendInt32(o, int32(z.Op))
	o = append(o, 0x82)
	if oTemp, err := z.Instance.MarshalHash(); err != nil {
		return nil, err
	} else {
		o = msgp.AppendBytes(o, oTemp)
	}
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *UpdateServiceHeader) Msgsize() (s int) {
	s = 1 + 3 + msgp.Int32Size + 9 + z.Instance.Msgsize()
	return
}

// MarshalHash marshals for hash
func (z UpdateServiceResponse) MarshalHash() (o []byte, err error) {
	var b []byte
	o = msgp.Require(b, z.Msgsize())
	// map header, size 0
	o = append(o, 0x80)
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z UpdateServiceResponse) Msgsize() (s int) {
	s = 1
	return
}

// MarshalHash marshals for hash
func (z UpdateType) MarshalHash() (o []byte, err error) {
	var b []byte
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendInt32(o, int32(z))
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z UpdateType) Msgsize() (s int) {
	s = msgp.Int32Size
	return
}
